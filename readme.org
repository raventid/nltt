#+TITLE: Readme

* Преамбула
Я умышленное не выкладываю в открытый доступ задание и использую репозиторий с обфуцированным названием. Могу удалить этот код после просмостра, чтобы не светить тестовое.

* Краткое описание
Краткое описание того, что получилось.

- Клиент-серверное приложение на TCP.
- Все выборы были сделаны на мое усмотрение. Tcp vs Udp vs Grpc/ tokio vs async / HashMap vs VecDeque. Если появлялся вопрос по внутренней логике приложения, то я делал выбор и старался комментировать его в коде, рядом с реализацией.
- Фреймовый протокол поверх TCP. Можно было разработать разные протоколы для игры и для апи-сервера, но в целях простоты и экономии времени проект реализует единный протокол.
- Все реализовано с использованием экосистемы Tokio (tokio-streams, tokio-codec, etc)
- Приложение не использует никакие внешние хранилища, все реализовано in-memory (можно было бы статистику вынести в отдельное хранилище со своим API, но насколько я понимаю не в этом суть задания)
- Минимально используются внешние пакеты. Только в одном месте не хотелось писать linked-hash-map, поэтому был взят готовый пакет.
- В основном все структуры данных и подходы выбирались исходя из приоритетов: Скорость реализации, Производительность. В первую очередь выполнялись функциональные требования, во вторую учитывалась производительность.
- Приложение не доработано до боевого состояния. Например список всех пользователей хранится в памяти и если приложение будет работать бесконечно долго, то оно рано или поздно упадет по OOM. В клиентской части имеются необязательные unwrap(), поэтому клиент может запаниковать в случае, если сервер упал. На сервере я постарался правильно обработать ошибки, в случае плохих клиентов.
- Местами имеется избыточное копирование данных, для основных структур данных можно рассмотреть альтернативные варианты. Например использовать dashmap, где-то можно запараллелить обработку. Но это потребует каких-то бенчмарков и замеров, а соответственно времени, поэтому все структуры выбраны на глаз.
- Есть и решения под знаком вопроса. Например токен авторизации используется как id клиента. В данной интерпретации это было допустимо, но если придумать дополнительные ограничения, то такой вариант может не подойти.
- Весь код снабжен подробными комментариями

Приятного просмотра!
