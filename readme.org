#+TITLE: Readme

* Преамбула
Я умышленное не выкладываю в открытый доступ задание и использую репозиторий с обфуцированным названием. Могу удалить этот код после просмостра, чтобы не светить тестовое.

* Краткое описание
Краткое описание того, что получилось.

- Клиент-серверное приложение на TCP.
- Все выборы были сделаны на мое усмотрение. Tcp vs Udp vs Grpc/ tokio vs async / HashMap vs VecDeque. Если появлялся вопрос по внутренней логике приложения, то я делал выбор и старался комментировать его в коде, рядом с реализацией.
- Фреймовый протокол поверх TCP. Можно было разработать разные протоколы для игры и для апи-сервера, но в целях простоты и экономии времени проект реализует единный протокол.
- Все реализовано с использованием экосистемы Tokio (tokio-streams, tokio-codec, etc)
- Приложение не использует никакие внешние хранилища, все реализовано in-memory (можно было бы статистику вынести в отдельное хранилище со своим API, но насколько я понимаю не в этом суть задания)
- Минимально используются внешние пакеты. Только в одном месте не хотелось писать linked-hash-map, поэтому был взят готовый пакет.
- В основном все структуры данных и подходы выбирались исходя из приоритетов: Скорость реализации, Производительность. В первую очередь выполнялись функциональные требования, во вторую учитывалась производительность.
- Приложение не доработано до боевого состояния. Например список всех пользователей хранится в памяти и если приложение будет работать бесконечно долго, то оно рано или поздно упадет по OOM. В клиентской части имеются необязательные unwrap(), поэтому клиент может запаниковать в случае, если сервер упал. На сервере я постарался правильно обработать ошибки, в случае плохих клиентов, но некоторые send.await все равно игнорируют result и потребуют доп. полировки
- Местами имеется избыточное копирование данных, для основных структур данных можно рассмотреть альтернативные варианты. Например использовать dashmap, где-то можно запараллелить обработку. Но это потребует каких-то бенчмарков и замеров, а соответственно времени, поэтому все структуры выбраны на глаз.
- Есть и решения под знаком вопроса. Например токен авторизации используется как id клиента. В данной интерпретации это было допустимо, но если придумать дополнительные ограничения, то такой вариант может не подойти.
- Весь код снабжен подробными комментариями

Конечно нет предела совершенству. Нужно доработать логгирование (надо бы взять tokio-tracing), улучшить гранулярность локов (т.к. лидерборд я делал в самом конце и времени было мало, то я свалил счетчик побед в одну кучу с информацией о peer и там берется общий лок на это все, что не очень хорошо для перфоманса), надо бы добавить интеграционных тестов и написать poperty тесты на основные структуры. Но в целом функциональные требования выполнены, что уже неплохо!

Приятного просмотра!

* Как запустить
Сервер с отладочной печатью. Ее можно выключить убрав дебаг ключ.
#+begin_src bash
GAME_SERVER_PORT=8000 API_SERVER_PORT=8010 RUST_LOG="debug" cargo run --bin server
#+end_src

Клиент. #+begin_src
GAME_SERVER_PORT=8000 RUST_LOG="debug" cargo run --bin client
#+end_src

Я не принял решение относительно того куда положить токены ключи, поэтому если есть необходимость я добавил опциональный ENV для ключа, для удобства добавлю их сюда в команды. При подключении клиент напечатает под какой подписью он подключился. Возможно стоило в файл положить, но не успел продумать как это удобно сделать.
#+begin_src
SIGNATURE=96a9354f-a8bc-4895-8317-61bf73f127c8 GAME_SERVER_PORT=8000 RUST_LOG="debug" cargo run --bin client
SIGNATURE=fc5d5532-d8c1-4a7d-b035-c2edc8ba66c6 GAME_SERVER_PORT=8000 RUST_LOG="debug" cargo run --bin client
#+end_src

Статистика с апи сервера. Скрипт идет на апи сервер и печатает статиситку в stdout.
#+begin_src bash
API_SERVER_PORT=8010 RUST_LOG="debug" cargo run --bin get_wins_log
#+end_src


Статистика с по пользователям. Скрипт идет на апи сервер и печатает статиситку в stdout.
#+begin_src bash
API_SERVER_PORT=8010 RUST_LOG="debug" cargo run --bin get_sorted_winners
#+end_src

Как запустить множество клиентов это выбор пользователя. Я просто открываю в разных табах консоли.
